# 1장 아파치 카프카 개요

## 1.1 이 장의 내용
1장에서는 아파치 카프카로 무엇을 할 수 있는지 살펴본다. 더불어 아파치 카프카가 탄생한 배경과 현재 산업계에 어떤 영향을 주고 있는지에 대해서도 알아본다.

## 1.2 아파치 카프카
이파치 카프카는 여러 대의 분산 서버에서 대량의 데이터를 처맇하는 분산 메시징 시스템이다. 메시지(데이터)를 받고, 받은 메시지를 다른 시스템이나 장치에 보내기 위해 사용된다. 카프카는 여러 시스템과 장치를 연결하는 중요한 역할을 한다.
빅데이터, 사물인터넷, 인공지능이라는 IT트렌드에서도 알 수 있듯이 데이터 활용의 중요성이 높아지고 있으며 이와 동시에 데이터를 얼마나 받을수 있는가 도 주목하게 되었다.
카프카는 대량의 데이터를 **높은 처리량** 과 **실시간**으로 취급하기 위한 제품으로 다음 4가지를 할 수 있다.

* 확장성 : 어러 서버로 '확장 구성'할 수 있기 때문에 데이터 양에 따라 시스템 확장이 가능하다.
* 영속성 : 수신한 데이터를 '디스크에 유지'할 수 있기 때문에 언제라도 데이터를 읽을 수 있다.
* 유연성 : '연계할 수 잇는 제품이 많기' 때문에 제품이나 시스템을 연결하는 허브 역할을 한다.
* 신뢰성 : '메시지 전달 보증'을 하므로 데이터 분실을 걱정하지 않아도 된다.

카프카는 원래 높은 처리량으로 데이터를 실시간 처리하는 처리 성능에 초점을 두었고, 이후 기능과 신뢰성을 향상시켜 현재는 종합 스트림 처리를 위한 플랫폼이 되고 있다.

카프카는 오픈소스로 공개되어 있으며 여러기업의 엔지니어들이 참여하고 있는 커뮤니티에서 개발되고 있다. 오픈소스 제품에 흔히 존재하는 기업용인 엔터프라이즈 버전이 존재하지 않고 핵심 부분은 커뮤니티 버전 밖에 없다는 점도 매력적이다.

## 1.4 카프카로 링크드인 요구 사항 실현하기
여기서는 카프카가 링크드인 요구 사항을 어떤 수단으로 실현했는지 살펴본다.

***요구사항***
  1. 높은 처리량으로 실시간 처리한다.
  2. 임의의 타이밍에 데이터를 읽는다.
  3. 다양한 제품과 시스템에 쉽게 연동한다.
  4. 메시지를 잃지 않는다.

***실현수단***
  1. 메시징 모델고가 스케일 아웃형 아키텍쳐
  2. 디스크로의 데이터 영속화
  3. 이해하기 쉬운 API 제공
  4. 전달 보증

### 1.4.1 메시징 모델과 스케일 아웃
일반적으로 메시징 모델은 다음 세 가지 요소로 구성된다
>  Producer : 메시지 생산자
>  
>  Broker : 메시지 수집/전달 역할
>  
>  Consumer : 메시지 소비자

카프카 메시징 모델을 설명하는 데 있어 기존의 메시징 모델인 큐잉모델과 펍/섭 메시징 모델 두가지 모델을 살펴보자.

**큐잉 모델**
브로커 안에 큐를 준비해, 프로듀서에서의 메시지가 큐에 담기고, 컨슈머가 큐에서 메시지를 추출한다. 하나의 큐에 대해 컨슈머가 여러 개 존재하는 것을 생각할 수 있다. 이 모델은 컨슈머를 여러 개 준비함으로써 컨슈머에 의한 처리를 확장시킬 수 있으며, 컨수머가 메시지를 받으면 다른 컨수머는 메시지를 받을 수 없다.

**펍/섭 모델**
펍/섭 메시징 모델은 티비나 라디오 전파 수신을 상상하면 이해하기 쉽다. TV 방송국과 라디오 방송국은 개별 가정에서 누가 수신하고 있는지 고려하지 않고 방송 전파를 발신하며, 각 가정은 자신이 보고 싶은 프로그램만 선택하여 방송을 수신한다. 이렇게 하면 발신자와  수신자 연결이 유연한 장점이 있다. 이와 같은 구조를 시스템 간 실현한다고 생각하면 된다. 시스템 아키텍쳐에 있어서 이 발신자와 수신자의 교환을 중개하는 브로커가 존재함으로써 펍/섭 메시징 모델이 형성된다.

1개의 토픽에 주목한 경우를 큐잉 모델과 비교하면 여렇이 존재하는 모든 서브스크라이버는 동일한 메시지를 받게 된다. 병렬로 동작하는 복수의 서브스크라이버에 전달할 수 있다는 장점이 있지만, 동일한 메시지에 대한 처리이기 때문에 브로커의 토픽에 축적되는 메시지 그룹 입장에서 보면 처리능력을 높이는 효과는 없다. 따라서 큐잉 모델과 펍/섭 메시징 모델은 장점과 단점이 공존한다.

### 1.4.2 카프카 메시징 모델
높은 처리량을 실현하기 위해서는 어떻게 확장성 있는 구성을 할수있을지가 관건이다.
따라서 카프카에서는 큐잉 모델에서 실현한 **여러 컨슈머가 분산 처리로 메시지를 소비**하는 모델과 펍/섭 메시징 모델에서 실현한 **여러 섭스크라이버에 동일한 메시지를 전달**하고, **토픽기반으로 전달 내용을 변경**하는 모델로 되어있다. 이 모델을 실현하기 위해 '컨수머 그룹'이라는 개념을 도입하여 컨수머를 확장 구성할 수 있도록 설계하고 있다.
여러 컨수머가 동일 토픽을 분산하여 메시지를 읽음으로써 처리의 확장성을 담보한다. 단, 시스템 구성상 브로커가 1대라면 그곳이 병목이 될거라고 쉽게 상상할 수 있다. 또한 장기간에 걸쳐 임의의 타이밍에 데이터를 읽도록 하려면 1대만으로는 유지할 수 있는양이 부족할지도 모른다. 따라서 브로커도 복수 구성으로 동작하도록 되었으며, 결과적으로는 전체적으로 확장 구성을 하고 있는 셈이다.

### 1.4.3 디스크로의 데이터 영속화
메시지 큐에서도 데이터 영속화를 실시하는 제품이 있지만 실시간 접속에만 중점을 두고 있는 경우가 많으며 기본적으로 장기보존을 가정하지 않는다. 배치 처리의 경우에는 데이터를 일정기간마다 모아야 할 필요가 있기 때문에 데이터를 메모리에서만 유지하는 것은 용량 면에서 불가능하다. 따라서 카프카의 메시지 영속화는 디스크에서 이루어진다. 카프카는 **디스크에 영속화함에도 불구하고 높은 처리량을 제공**한다는 특징이 있다.
또한 속속 들어오는 데이터를 받아들이면서 한 묶음으로 장기 보존을 목적으로 영속홯할 수 있기 대문에 카프카를 **스토리지 시스템**으로도 간주할 수 있다. 이러한 특징을 활용하는 예로는 처리 순서대로 로그를 계속 남기는 커밋 로그를 축적하기 위한 스토리지 시스템 등을 들 수 있다.

### 1.4.4 이해하기 쉬운 API 제공
카프카는 프로듀서와 컨수머를 쉽게 접속할 수 있도록 'Connect API'를 제공한다. 또한 API를 기반으로 카프카에 접속하기 위한 프레임워크로 Kafka Connect도 제공한다.
카프카에 존재하고 있는 데이터를 스트림 처리하는 Streams API를 라이브러리화한 Kafka Streams라는 클라이언트 라이브러리가 준비되어 있다. 사요자는 Kafka Streams 라이브러리를 이용해서 자바 애플리케이션을 만들고, 작동시킬 수 있기 때문에 카프카 이출력에 사용하는 스트림 처리 애플리케이션을 비교적 쉽게 구현할 수 있다.

### 1.4.5 전달 보증
카프카에서는 'At Most Once', 'At Least Once', 'Exactly Once' 세 가지 수준으로 전달을 보증한다.

**At Least Once 실현**
At Least Once를 실현하기 위해 Ack와 오프셋 커밋이라는 개념을 도입하고 있다. Ack는 브로커가 메시지를 수신했을 때 프로듀서에게 수신 완료했다는 응답을 뜻한다. 이것을 이용해 프로듀서가 Ack를 받지 못한 경우에 재전송해야 한다고 판단할 수 있다.
또한 컨수머가 브로커로부터 메시지를 받을 때 컨수머가 어디까지 메시지를 받았는지를 관리하기 위한 오프셋이 있으며, 이를 이용한 전달 범위 보증의 구조를 오프셋 커밋이라고 한다. 오프셋 커밋은 메시지를 받아 정상적으로 처리를 완료한 다음 오프셋을 업데이트함으로써 어긴가 잘못된 문제로 메시지를 재전송할 때도 어디부터 재전송하면 되는지 판단할 수 있다.

**Exactly Once 실현**
Exactlyy Once 수준에서는 구체적으로 쌍방간의 실현이 모두 필요한데, 첫 번째는 프로듀서와 브로커의 상호 교환 사이에서, 그리고 두번째는 브로커와 컨수머의 상호 교환 사이에서 필요하다. 우선, 프로듀서와 브로커의 상호 교환 사이를 살펴보면 양쪽 모두에서 시퀀스 번호를 관리해 중복되는 실행을 제거하는 방법을 사용한다.
한편, 브로커와 컨슈머 간 교환에 있어서는 컨수머에 대해 트랜잭션의 범위를 해석하고, 트랜잭션 중단 시, 중단까지의 처리를 파기하는 기능이 있다.
Exactlyy Once 수준의 전달을 보증하려면 카프카 뿐만 아니라 프로듀서에 해당하는 상류 시스템과 컨수머에 해당하는 하류 시스템에도 상태 관리를 요구하게 된다. 따라서 카프카 단독으로는 전달 보증을 실현하긴 어렵다. 하지만 적어도 카프카는 트랜잭션 관리 메커니즘을 갖추고 있기 때문에 상류와 하류 시스템 사이에서 필요로 하는 상태 관리를 위한 조건이 갖추어지면 전달은 보증된다.








